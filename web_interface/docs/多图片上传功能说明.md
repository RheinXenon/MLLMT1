# 多图片上传功能说明

## 功能概述

系统现已支持一次上传和分析多张图片（最多5张），适用于需要对比分析多张医学影像的场景。配合智能的图片上下文管理策略，在保证分析质量的同时优化显存占用。

## 主要特性

1. **多图片选择**：支持一次性选择多张图片（Ctrl/Cmd + 点击）
2. **实时预览**：显示所有已选图片的缩略图预览
3. **独立管理**：每张图片可以单独删除
4. **批量上传**：所有选中的图片会一起发送给AI模型分析
5. **数量限制**：最多支持5张图片同时上传
6. **智能压缩**：自动压缩大图片以优化显存占用
7. **上下文记忆**：支持在多轮对话中引用历史图片

## 使用方法

### 1. 选择多张图片
- 点击输入框左侧的"📎"按钮
- 在文件选择对话框中，按住Ctrl(Windows)或Cmd(Mac)键选择多张图片
- 或者拖动选择多张图片

### 2. 管理已选图片
- 选中的图片会显示在输入框上方的预览区域
- 每张图片右上角有"✕"按钮，点击可单独移除
- 预览区域显示已选图片数量（如"已选择 3 张图片"）

### 3. 发送分析
- 输入问题描述（建议明确说明需要对比分析的方面）
- 点击"发送"按钮
- AI会同时分析所有上传的图片

### 4. 多轮对话中的图片引用
- 上传的图片会保存在会话历史中
- 在后续对话中，你可以继续询问关于这些图片的问题
- 系统会智能管理图片上下文，优化性能

## 使用建议

为了获得更好的多图片分析效果，建议在提示词中：
- **明确说明希望对比分析的方面**
  - 示例："对比这三张不同时期的CT扫描，分析病灶的变化趋势"
- **指出需要特别关注的区域**
  - 示例："重点分析这两张X光片中肺部的阴影区域"
- **说明图片之间的关系**
  - 示例："第一张是治疗前，第二张是治疗一个月后，第三张是治疗三个月后"
  
**更多示例提示词：**
- "分析这两张不同角度的X光片，判断骨折的位置和严重程度"
- "比较这几张超声图像，评估治疗前后的效果"
- "这三张是同一患者不同时期的影像，请分析病情发展趋势"

## 技术实现

### 前端实现 (frontend/)

#### HTML 结构 (index.html)
- `<input type="file" multiple>`：支持多文件选择
- `.image-preview-container`：图片预览容器
- `.image-preview-list`：图片列表展示区

#### 样式 (static/css/style.css)
- `.image-preview-container`：预览容器样式，包含淡入淡出动画
- `.image-preview-list`：横向滚动的图片列表布局
- `.image-preview-item`：单个图片预览项（包含缩略图和删除按钮）
- `.message-images`：消息中的多图片网格布局
- `.image-count-badge`：图片数量徽章样式

#### JavaScript 逻辑 (static/js/main.js)

**状态管理：**
```javascript
appState.currentImages = []  // 存储当前选中的多张图片（File对象数组）
```

**核心函数：**
- `handleImageSelect(e)`：处理多文件选择
  - 限制最多5张图片
  - 验证文件类型（必须是图片）
  - 验证文件大小（最大16MB）
  - 添加到`currentImages`数组

- `updateImagePreview()`：更新预览显示
  - 显示图片数量徽章
  - 为每张图片创建预览项
  - 添加独立的删除按钮

- `handleRemoveSingleImage(index)`：移除指定索引的图片
- `handleRemoveAllImages()`：清空所有图片
- `addMessageToDOM(role, content, imageUrls)`：在消息中显示多张图片

**API调用：**
```javascript
await apiClient.chatStream(
    prompt, 
    appState.currentImages,  // 传递File对象数组
    config, 
    sessionId,
    onChunk,
    onComplete,
    onError
);
```

### 后端实现 (backend/)

#### Flask API (app.py)

**接收多张图片：**
```python
# 使用getlist接收多个文件
files = request.files.getlist('images')
image_paths = []

for file in files:
    if file and file.filename and allowed_file(file.filename):
        # 添加时间戳避免文件名冲突
        filename = secure_filename(file.filename)
        timestamp = str(int(time.time() * 1000))
        base, ext = os.path.splitext(filename)
        filename = f"{base}_{timestamp}{ext}"
        
        image_path = os.path.join(config.UPLOAD_FOLDER, filename)
        file.save(image_path)
        image_paths.append(image_path)
```

**会话历史管理：**
- 用户消息中保存`image_paths`列表，用于后续对话
- 保留原始图片文件，仅删除临时压缩文件
- 清除会话时一并删除相关图片文件

**端点说明：**
- `/api/chat`：非流式对话（返回完整响应）
- `/api/chat_stream`：流式对话（Server-Sent Events）
- `/api/clear_history`：清除对话历史及关联图片

#### 图片上下文管理器 (image_context_manager.py)

这是多图片功能的核心优化模块，解决了多模态对话中的显存和性能问题。

**核心策略（ImageContextStrategy）：**

1. **CURRENT_ONLY**（当前图片模式）
   - 仅处理当前轮次的图片
   - 历史图片不参与编码，仅显示文本提示
   - 性能最优，适合显存受限场景

2. **CURRENT_WITH_TEXT_HISTORY**（推荐模式）
   - 当前图片正常编码
   - 历史图片转换为文本描述（图片摘要）
   - 平衡性能和上下文连续性

3. **CURRENT_WITH_RECENT_IMAGES**（高质量模式）
   - 当前图片 + 最近N张历史图片一起编码
   - 提供最完整的视觉上下文
   - 显存占用较高

**主要功能：**
```python
class ImageContextManager:
    def process_conversation_images(
        self, 
        current_image_paths: List[str],
        history: List[Dict[str, Any]],
        processor,
        model
    ) -> Tuple[List[Dict[str, Any]], List[str]]:
        """
        根据策略处理对话中的图片
        返回：(处理后的消息列表, 需要编码的图片路径列表)
        """
        
    def generate_image_summary(
        self,
        image_path: str,
        processor,
        model,
        device
    ) -> str:
        """为图片生成简短的文本摘要（用于历史图片）"""
```

**图片摘要缓存：**
- 使用MD5哈希标识图片
- 缓存已生成的图片摘要
- 避免重复生成，提升性能

### 显存优化机制

#### 图片自动压缩
- **配置参数**（config.py）：
  - `MAX_PIXELS`：最大像素数（默认1003520，约100万像素）
  - `IMAGE_COMPRESSION_MAX_SIZE`：压缩后最大边长（默认1024px）
  
- **压缩流程**（model_manager.py）：
  ```python
  def compress_image(self, image_path: str) -> str:
      """压缩图片以优化显存占用"""
      # 1. 读取图片
      # 2. 保持宽高比缩放到指定尺寸
      # 3. 保存为临时压缩文件
      # 4. 返回压缩后的路径
  ```

#### 临时文件管理
- **原始图片**：保存在`uploads/`目录，用于后续对话
- **压缩图片**：临时文件，处理完成后立即删除
- **清理机制**：
  - 对话完成后清理压缩文件
  - 清除会话时清理原始图片
  - 确保磁盘空间不被占用

## 限制与注意事项

### 前端限制
1. **数量限制**：最多支持5张图片同时上传（可在`main.js`中调整`MAX_IMAGES`常量）
2. **文件大小**：每张图片最大16MB
3. **文件格式**：仅支持图片文件（通过`file.type.startsWith('image/')`检查）

### 后端限制
1. **允许的文件扩展名**：png, jpg, jpeg, gif, bmp, webp（可在`config.py`中的`ALLOWED_EXTENSIONS`配置）
2. **最大请求大小**：由`MAX_FILE_SIZE`配置（默认16MB）
3. **并发限制**：同时处理的请求数受`MAX_CONCURRENT_REQUESTS`限制（默认3个）

### 性能考虑
1. **显存占用**：
   - 每张图片编码都会占用显存
   - 推荐使用`CURRENT_WITH_TEXT_HISTORY`策略平衡性能
   - 如遇显存不足，可调整`MAX_PIXELS`或使用`CURRENT_ONLY`策略

2. **处理速度**：
   - 多张图片会增加处理时间
   - 图片压缩会略微增加预处理时间
   - 流式输出可改善用户体验

3. **磁盘空间**：
   - 原始图片保留在会话中，占用磁盘空间
   - 建议定期清理旧会话
   - 压缩文件自动清理，不占用长期空间

## 配置选项

可在`web_interface/backend/config.py`中调整以下参数：

```python
# 图片相关配置
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp'}
MAX_FILE_SIZE = 16 * 1024 * 1024  # 16MB
UPLOAD_FOLDER = os.path.join(PROJECT_ROOT, "web_interface", "uploads")

# 显存优化配置（针对8GB显存优化）
MAX_PIXELS = 1003520  # 约100万像素（原始1280万 -> 100万，减少约12倍显存占用）
IMAGE_COMPRESSION_MAX_SIZE = 1024  # 图片预处理最大边长（像素）

# 图片上下文策略配置
IMAGE_CONTEXT_STRATEGY = 'current_with_text_history'  # 推荐使用此策略
# 可选值：
# - 'current_only'：仅使用当前图片（性能最优，适合8GB显存）
# - 'current_with_text_history'：当前图片 + 历史图片文本描述（推荐，平衡性能和上下文）
# - 'current_with_recent_images'：当前图片 + 最近N张历史图片（高质量，但性能较差）

MAX_RECENT_IMAGES = 2  # 策略3中保留的最近图片数量
ENABLE_IMAGE_SUMMARY = True  # 是否启用图片摘要功能（首次上传时生成）

# 并发控制配置
MAX_CONCURRENT_REQUESTS = 3  # 最大并发请求数（防止服务器过载）
REQUEST_TIMEOUT = 300  # 请求超时时间（秒）
```

## 向后兼容性

系统保持良好的向后兼容性：

1. **前端兼容**：
   - 支持单张图片的旧使用方式
   - 旧版本消息格式（`imageUrl`字符串）自动转换为新格式（`imageUrls`数组）
   - 新旧聊天记录可无缝加载

2. **后端兼容**：
   - `request.files.getlist('images')`可处理单个或多个文件
   - 空图片列表（`[]`）正常处理为纯文本对话
   - 历史数据结构向后兼容

3. **API兼容**：
   - 所有端点同时支持单图和多图
   - 返回格式保持一致
   - session_id机制完全兼容

## 工作流程示例

### 单次多图片分析
```
用户操作：
1. 点击📎按钮
2. 选择3张X光片
3. 输入"对比分析这三张X光片，找出异常"
4. 点击发送

系统处理：
1. 前端验证文件数量和格式
2. 显示3张图片的预览
3. 通过FormData上传图片和问题
4. 后端保存3张原始图片
5. 压缩图片到合适尺寸
6. 模型编码3张图片并生成回复
7. 流式返回分析结果
8. 清理3张临时压缩文件
9. 保留原始图片用于后续对话
```

### 多轮对话中的图片引用
```
第一轮：
用户：[上传2张CT扫描] "这两张CT有什么区别？"
系统：分析两张图片的差异...

第二轮（无新图片）：
用户："第一张图片中的阴影区域严重吗？"
系统：根据图片上下文策略处理：
  - CURRENT_ONLY：提示用户图片在第一条消息中
  - CURRENT_WITH_TEXT_HISTORY：使用缓存的图片描述
  - CURRENT_WITH_RECENT_IMAGES：重新编码第一轮的图片

第三轮（新图片）：
用户：[上传1张新CT] "这是治疗后的结果，与之前相比如何？"
系统：智能处理当前图片和历史图片的关系...
```

## 故障排查

### 问题1：图片上传失败
**可能原因**：
- 文件过大（>16MB）
- 文件格式不支持
- 服务器繁忙（并发限制）

**解决方法**：
- 压缩图片后重试
- 检查文件格式
- 等待其他请求完成

### 问题2：显存不足
**可能原因**：
- 一次上传过多图片
- 图片分辨率过高
- 使用了`current_with_recent_images`策略

**解决方法**：
- 减少上传图片数量
- 调小`MAX_PIXELS`参数
- 切换到`current_only`或`current_with_text_history`策略

### 问题3：多图片分析不完整
**可能原因**：
- 提示词不够明确
- 图片过多导致上下文不足
- 模型token限制

**解决方法**：
- 在提示词中明确说明要分析所有图片
- 分批次上传图片
- 适当增加`max_new_tokens`参数

## 更新日志

### 2025年11月3日
- ✅ 更新文档以反映实际代码实现
- ✅ 添加图片上下文管理器详细说明
- ✅ 补充显存优化机制说明
- ✅ 添加配置选项和工作流程示例
- ✅ 添加故障排查指南
- ❌ 移除了未实现的"多图片提示词增强"功能描述

### 2025年11月2日
- ✅ 初始版本：基础多图片上传功能
- ✅ 实现前后端多图片处理
- ✅ 添加图片预览和管理功能

